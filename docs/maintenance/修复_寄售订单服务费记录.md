# 修复：寄售订单服务费记录

**修复日期**：2025-12-27  
**修复类型**：功能增强  
**影响范围**：寄售订单记录、用户寄售列表接口

---

## 一、问题描述

### 1.1 原问题
用户提交寄售时，系统会从确权金中扣除服务费（默认3%），但寄售订单记录（`ba_collection_consignment`）中只记录了寄售价格（`price`），没有记录服务费金额，导致：

1. **数据不完整**：无法追溯用户实际付出的成本（寄售价格 + 服务费）
2. **统计困难**：财务统计和用户成本分析时缺少关键数据
3. **对账问题**：无法从寄售记录中直接看出用户的总支出

### 1.2 示例说明
**场景**：用户寄售价格500元的藏品

**原实现**：
- 扣除确权金：15元（3%）
- 寄售记录只记录：`price = 500`
- **问题**：无法从记录中看出用户实际付出了515元（500 + 15）

**修复后**：
- 扣除确权金：15元（3%）
- 寄售记录：`price = 500`, `service_fee = 15`
- **优势**：可以清晰看出用户实际成本 `total_cost = price + service_fee = 515`

---

## 二、修复内容

### 2.1 数据库变更

#### 添加 `service_fee` 字段
```sql
-- 文件：database/add_service_fee_to_consignment.sql

ALTER TABLE `ba_collection_consignment`
ADD COLUMN `service_fee` decimal(12,2) NOT NULL DEFAULT '0.00' 
COMMENT '服务费（从确权金扣除）' AFTER `price`;
```

**字段说明**：
- **类型**：`decimal(12,2)` - 支持精确到分
- **默认值**：`0.00` - 免费重发时服务费为0
- **位置**：紧跟在 `price` 字段之后
- **含义**：用户提交寄售时从确权金扣除的服务费

#### 表结构更新后
```sql
DESC ba_collection_consignment;
```

| Field | Type | Null | Key | Default | Extra |
|-------|------|------|-----|---------|-------|
| id | int unsigned | NO | PRI | NULL | auto_increment |
| user_id | int unsigned | NO | MUL | 0 | |
| user_collection_id | int unsigned | NO | MUL | 0 | |
| item_id | int unsigned | NO | MUL | 0 | |
| package_id | int unsigned | NO | MUL | 0 | |
| package_name | varchar(100) | NO | | | |
| price | decimal(12,2) | NO | | 0.00 | |
| **service_fee** | **decimal(12,2)** | **NO** | | **0.00** | ✅ **新增** |
| status | tinyint unsigned | NO | | 1 | |
| create_time | int unsigned | NO | | 0 | |
| update_time | int unsigned | NO | | 0 | |

---

### 2.2 代码修改

#### 1. 寄售创建逻辑（`app/api/controller/CollectionItem.php`）

**修改位置**：第2227行

**修改前**：
```php
// 7. 生成寄售记录（商品上架到商城，包含资产包信息）
$consignmentId = Db::name('collection_consignment')->insertGetId([
    'user_id'           => $userId,
    'user_collection_id'=> $userCollectionId,
    'item_id'           => $collection['item_id'],
    'package_id'        => $packageId,
    'package_name'      => $packageName,
    'price'             => $consignmentPrice,
    'status'            => 1, // 1=寄售中
    'create_time'       => $now,
    'update_time'       => $now,
]);
```

**修改后**：
```php
// 7. 生成寄售记录（商品上架到商城，包含资产包信息）
$consignmentId = Db::name('collection_consignment')->insertGetId([
    'user_id'           => $userId,
    'user_collection_id'=> $userCollectionId,
    'item_id'           => $collection['item_id'],
    'package_id'        => $packageId,
    'package_name'      => $packageName,
    'price'             => $consignmentPrice,
    'service_fee'       => $serviceFee, // ✅ 记录服务费（用户实际成本 = price + service_fee）
    'status'            => 1, // 1=寄售中
    'create_time'       => $now,
    'update_time'       => $now,
]);
```

**说明**：
- `$serviceFee` 变量在前面已计算（第1927-1938行）
- 如果是免费重发（流拍后），`$serviceFee = 0`
- 正常寄售时，`$serviceFee = 寄售价格 × 服务费率（默认3%）`

---

#### 2. 我的寄售列表接口（`app/api/controller/CollectionItem.php`）

**修改位置**：第2492-2530行

**A. 查询字段增加**（第2492-2511行）

**修改前**：
```php
$list = $query
    ->field([
        'c.id AS consignment_id',
        'c.user_id',
        'c.user_collection_id',
        'c.item_id',
        'c.price AS consignment_price',
        'c.status AS consignment_status',
        // ... 其他字段
    ])
```

**修改后**：
```php
$list = $query
    ->field([
        'c.id AS consignment_id',
        'c.user_id',
        'c.user_collection_id',
        'c.item_id',
        'c.price AS consignment_price',
        'c.service_fee', // ✅ 新增：服务费
        'c.status AS consignment_status',
        // ... 其他字段
    ])
```

**B. 数据处理增加**（第2521-2530行）

**修改前**：
```php
foreach ($list as &$row) {
    $row['image'] = $row['image'] ? full_url($row['image'], false) : '';
    $row['original_price'] = isset($row['original_price']) ? (float)$row['original_price'] : 0.0;
    $row['consignment_price'] = (float)$row['consignment_price'];
    $row['consignment_status'] = (int)$row['consignment_status'];
    // ...
}
```

**修改后**：
```php
foreach ($list as &$row) {
    $row['image'] = $row['image'] ? full_url($row['image'], false) : '';
    $row['original_price'] = isset($row['original_price']) ? (float)$row['original_price'] : 0.0;
    $row['consignment_price'] = (float)$row['consignment_price'];
    $row['service_fee'] = isset($row['service_fee']) ? (float)$row['service_fee'] : 0.0; // ✅ 新增
    // ✅ 新增：用户实际成本 = 寄售价格 + 服务费
    $row['total_cost'] = $row['consignment_price'] + $row['service_fee'];
    $row['consignment_status'] = (int)$row['consignment_status'];
    // ...
}
```

**C. API文档更新**（第2439-2451行）

**修改前**：
```php
#[
    Apidoc\Title("我的寄售列表"),
    Apidoc\Tag("藏品商城,我的寄售"),
    Apidoc\Method("GET"),
    Apidoc\Url("/api/collectionItem/myConsignmentList"),
    // ...
]
```

**修改后**：
```php
#[
    Apidoc\Title("我的寄售列表"),
    Apidoc\Tag("藏品商城,我的寄售"),
    Apidoc\Method("GET"),
    Apidoc\Url("/api/collectionItem/myConsignmentList"),
    // ...
    Apidoc\Returned("list[].consignment_price", type: "float", desc: "寄售价格"),
    Apidoc\Returned("list[].service_fee", type: "float", desc: "服务费（从确权金扣除）"),
    Apidoc\Returned("list[].total_cost", type: "float", desc: "用户实际成本（寄售价格+服务费）"),
]
```

---

## 三、接口变更

### 3.1 `GET /api/collectionItem/myConsignmentList` - 我的寄售列表

#### 新增返回字段

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `list[].service_fee` | float | 服务费（从确权金扣除） | `15.00` |
| `list[].total_cost` | float | 用户实际成本（寄售价格+服务费） | `515.00` |

#### 返回数据示例

**修改前**：
```json
{
  "code": 1,
  "msg": "success",
  "data": {
    "list": [
      {
        "consignment_id": 123,
        "consignment_price": 500.00,
        "consignment_status": 1,
        "consignment_status_text": "寄售中",
        "title": "富春山居图",
        "image": "https://xxx.com/xxx.jpg"
      }
    ]
  }
}
```

**修改后**：
```json
{
  "code": 1,
  "msg": "success",
  "data": {
    "list": [
      {
        "consignment_id": 123,
        "consignment_price": 500.00,
        "service_fee": 15.00,
        "total_cost": 515.00,
        "consignment_status": 1,
        "consignment_status_text": "寄售中",
        "title": "富春山居图",
        "image": "https://xxx.com/xxx.jpg"
      }
    ]
  }
}
```

---

## 四、业务逻辑说明

### 4.1 服务费计算规则

#### 正常寄售
```
服务费 = 寄售价格 × 服务费率
默认服务费率 = 3%（可在后台配置：consignment_service_fee_rate）

示例：
寄售价格 = 500元
服务费 = 500 × 0.03 = 15元
```

#### 代理优惠
```
如果用户是代理（user_type >= 3），享受服务费折扣
折扣后服务费 = 基础服务费 × 代理折扣率
默认代理折扣率 = 1.0（可在后台配置：agent_service_discount）

示例（假设代理折扣率 = 0.8）：
寄售价格 = 500元
基础服务费 = 500 × 0.03 = 15元
折扣后服务费 = 15 × 0.8 = 12元
```

#### 免费重发
```
如果藏品之前寄售失败（流拍），用户重新上架时：
服务费 = 0元（不扣费）

条件：user_collection.free_consign_attempts > 0
```

### 4.2 用户成本构成

```
用户实际成本 = 寄售价格 + 服务费

正常寄售示例：
- 寄售价格：500元
- 服务费：15元
- 实际成本：515元

免费重发示例：
- 寄售价格：500元
- 服务费：0元
- 实际成本：500元
```

---

## 五、测试验证

### 5.1 数据库验证

```sql
-- 查看最新的寄售记录
SELECT 
    id, 
    user_id, 
    price as 寄售价格, 
    service_fee as 服务费,
    (price + service_fee) as 实际成本,
    status as 状态,
    create_time
FROM ba_collection_consignment
ORDER BY id DESC
LIMIT 10;
```

**预期结果**：
- 正常寄售：`service_fee` 应该是 `price × 0.03`
- 免费重发：`service_fee` 应该是 `0.00`

### 5.2 API 测试

#### 测试场景1：正常寄售
```bash
# 1. 用户提交寄售（价格500元）
curl -X POST "https://your-domain.com/api/collectionItem/consign" \
  -H "batoken: user_token" \
  -d "user_collection_id=123&consignment_price=500"

# 2. 查看我的寄售列表
curl -X GET "https://your-domain.com/api/collectionItem/myConsignmentList" \
  -H "batoken: user_token"
```

**预期返回**：
```json
{
  "list": [
    {
      "consignment_price": 500.00,
      "service_fee": 15.00,      // ✅ 应该是 500 × 0.03
      "total_cost": 515.00        // ✅ 应该是 500 + 15
    }
  ]
}
```

#### 测试场景2：免费重发
```bash
# 用户重新上架流拍的藏品
curl -X POST "https://your-domain.com/api/collectionItem/consign" \
  -H "batoken: user_token" \
  -d "user_collection_id=124&consignment_price=500"
```

**预期返回**：
```json
{
  "list": [
    {
      "consignment_price": 500.00,
      "service_fee": 0.00,       // ✅ 免费重发，服务费为0
      "total_cost": 500.00        // ✅ 应该是 500 + 0
    }
  ]
}
```

### 5.3 前端对接建议

#### 显示用户成本
```javascript
// 寄售列表页面
items.forEach(item => {
  console.log(`寄售价格: ¥${item.consignment_price}`);
  console.log(`服务费: ¥${item.service_fee}`);
  console.log(`实际成本: ¥${item.total_cost}`); // 寄售价格 + 服务费
});
```

#### UI展示示例
```
┌─────────────────────────┐
│ 富春山居图              │
│ 寄售中                  │
├─────────────────────────┤
│ 寄售价格: ¥500.00       │
│ 服务费:   ¥15.00        │
│ ─────────────────────── │
│ 实际成本: ¥515.00       │
└─────────────────────────┘
```

---

## 六、影响范围

### 6.1 影响的功能
✅ **正面影响**：
- 寄售订单创建（自动记录服务费）
- 我的寄售列表（显示服务费和实际成本）
- 财务统计和用户成本分析（数据更完整）

### 6.2 不影响的功能
✓ 服务费扣除逻辑（从确权金扣除）- 不变
✓ 寄售券消耗逻辑 - 不变
✓ 寄售撮合逻辑 - 不变
✓ 免费重发逻辑 - 不变

### 6.3 数据一致性
- ✅ 新增的寄售记录会自动记录服务费
- ✅ 历史寄售记录的 `service_fee` 默认为 `0.00`
- ✅ 用户活动日志（`user_activity_log`）中已有服务费记录，与新字段相互印证

---

## 七、后续优化建议

### 7.1 历史数据补全（可选）
如果需要补全历史寄售记录的服务费数据，可以运行以下SQL：

```sql
-- 从用户活动日志中提取服务费，更新到寄售记录
UPDATE ba_collection_consignment c
INNER JOIN (
    SELECT 
        JSON_UNQUOTE(JSON_EXTRACT(extra, '$.user_collection_id')) as uc_id,
        JSON_UNQUOTE(JSON_EXTRACT(extra, '$.service_fee')) as fee
    FROM ba_user_activity_log
    WHERE action_type = 'consignment_fee'
      AND JSON_EXTRACT(extra, '$.service_fee') IS NOT NULL
) log ON c.user_collection_id = log.uc_id
SET c.service_fee = log.fee
WHERE c.service_fee = 0.00;
```

**注意**：
- 此SQL仅补全 `service_fee = 0` 的记录
- 免费重发的记录不会被修改（因为日志中没有 `consignment_fee` 记录）

### 7.2 统计报表优化
建议在财务统计报表中增加：
- 用户寄售总成本统计（`SUM(price + service_fee)`）
- 服务费收入统计（`SUM(service_fee)`）
- 寄售成本占比分析

### 7.3 前端UI优化
建议在前端增加：
- 寄售成本明细展示（价格 + 服务费 = 总成本）
- 寄售前成本预览（用户提交前显示预估服务费）
- 寄售历史成本统计（用户总共支付了多少服务费）

---

## 八、总结

### 8.1 修复内容
- ✅ 数据库添加 `service_fee` 字段
- ✅ 寄售创建时记录服务费
- ✅ 寄售列表接口返回服务费和实际成本
- ✅ API 文档更新

### 8.2 业务价值
- ✅ 数据完整性：完整记录用户寄售成本
- ✅ 财务透明：用户可以清晰看到服务费明细
- ✅ 统计准确：财务报表和成本分析更精确
- ✅ 对账方便：便于财务对账和问题追溯

### 8.3 技术优势
- ✅ 兼容性好：历史数据默认服务费为0，不影响旧数据
- ✅ 扩展性强：为后续财务统计和成本分析提供基础
- ✅ 维护性好：数据结构清晰，易于理解和维护

---

**修复状态**：✅ 已完成  
**测试状态**：✅ 通过  
**文档状态**：✅ 已更新  

**修复人员**：AI Assistant  
**修复日期**：2025-12-27  
**文档版本**：v1.0

