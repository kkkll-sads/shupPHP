# 数据库性能优化方案：寄售表索引和约束

## 创建时间
2025-12-30

## 优化目标
优化 `ba_collection_consignment` 表的查询性能，并防止重复寄售问题

## 问题分析

### 1. 当前查询模式
代码中频繁执行以下查询：

```php
// 查询最近一条寄售记录（寄售接口中）
$lastConsignment = Db::name('collection_consignment')
    ->where('user_collection_id', $userCollectionId)
    ->order('id desc')
    ->find();

// 检查是否有进行中的寄售
$lastConsignment = Db::name('collection_consignment')
    ->where('user_collection_id', $userCollectionId)
    ->where('status', 1)  // 寄售中
    ->find();
```

### 2. 当前索引状态
```sql
- PRIMARY KEY (id)
- INDEX idx_user (user_id)
- INDEX idx_user_collection (user_collection_id)  -- 单列索引
- INDEX idx_item (item_id)
- INDEX idx_package_id (package_id)
```

**问题**：
- `idx_user_collection` 是单列索引，查询 `user_collection_id + status` 时无法充分利用
- 没有防止同一藏品重复寄售的约束

## 优化方案

### 方案 1：添加组合索引（推荐）

**SQL**：
```sql
-- 删除旧的单列索引
ALTER TABLE ba_collection_consignment DROP INDEX idx_user_collection;

-- 创建组合索引（user_collection_id, status）
CREATE INDEX idx_user_collection_status 
ON ba_collection_consignment(user_collection_id, status);
```

**优势**：
- ✅ 覆盖了 `WHERE user_collection_id = ? AND status = ?` 查询
- ✅ 也可以单独使用 `WHERE user_collection_id = ?`（最左前缀原则）
- ✅ 显著提升查询性能（预计 10-50 倍）

**注意**：
- 组合索引顺序很重要：`(user_collection_id, status)` 而不是 `(status, user_collection_id)`
- 因为通常先按 `user_collection_id` 筛选，再按 `status` 筛选

### 方案 2：唯一性约束（可选，需要评估）

#### 2.1 MySQL 8.0+ 使用函数索引（推荐）

```sql
-- MySQL 8.0.13+ 支持函数索引
CREATE UNIQUE INDEX idx_unique_active_consignment 
ON ba_collection_consignment(user_collection_id, (CASE WHEN status = 1 THEN 1 ELSE NULL END));
```

**优势**：
- ✅ 数据库层面强制约束
- ✅ 自动防止重复寄售

**劣势**：
- ❌ 需要 MySQL 8.0.13+
- ❌ 复杂度较高

#### 2.2 应用层 + 行锁（当前推荐）

代码中已经有基本的检查：

```php
// 在寄售接口中
$collection = Db::name('user_collection')
    ->where('id', $userCollectionId)
    ->where('user_id', $userId)
    ->lock(true)  // ✅ 已添加行锁
    ->find();

if ((int)$collection['consignment_status'] !== 0) {
    throw new \Exception('该藏品当前正在寄售中，无法再次寄售');
}
```

**优化建议**：
```php
// 事务开始时，立即锁定寄售记录
Db::startTrans();

// 锁定藏品记录
$collection = Db::name('user_collection')
    ->where('id', $userCollectionId)
    ->lock(true)
    ->find();

// 双重检查：再次查询寄售表确认
$activeConsignment = Db::name('collection_consignment')
    ->where('user_collection_id', $userCollectionId)
    ->where('status', 1)
    ->lock(true)  // ✅ 添加寄售表的行锁
    ->find();

if ($activeConsignment) {
    throw new \Exception('该藏品已有寄售记录（ID:' . $activeConsignment['id'] . '），请勿重复提交');
}

// ... 创建寄售记录 ...
Db::commit();
```

## 实施建议

### 立即实施（必要）
✅ **方案 1：添加组合索引**
- 性价比最高
- 无风险
- 显著提升性能

### 可选实施（根据业务需要）
🤔 **方案 2.2：应用层双重检查**
- 如果发现实际有重复寄售问题，再添加
- 当前代码已有基本保护

⏸️ **方案 2.1：唯一性约束**
- 暂不建议（除非 MySQL 版本 >= 8.0.13）
- 可作为未来优化方向

## 执行顺序

### 第一步：创建组合索引
```bash
mysql -u waibao -pweHPjtkrbAPSMCNm waibao < /opt/sqzx/database/migrations/add_consignment_index.sql
```

### 第二步（可选）：添加代码层双重检查
修改 `app/api/controller/CollectionItem.php::consign()` 方法

### 第三步：验证
```sql
-- 检查索引是否生效
EXPLAIN SELECT * FROM ba_collection_consignment 
WHERE user_collection_id = 141 AND status = 1;

-- 应该显示使用了 idx_user_collection_status 索引
```

## 性能预期

### 查询性能对比

**优化前**：
```sql
-- 使用单列索引 idx_user_collection
-- 需要扫描该藏品的所有寄售记录，然后过滤 status
EXPLAIN: type=ref, rows=3-5, Extra=Using where
```

**优化后**：
```sql
-- 使用组合索引 idx_user_collection_status
-- 直接定位到符合两个条件的记录
EXPLAIN: type=ref, rows=0-1, Extra=Using index
```

**预计提升**：10-50倍（取决于每个藏品的历史寄售记录数）

## 风险评估

### 添加索引的风险
- ✅ **低风险**：只是添加索引，不修改数据
- ✅ **可回滚**：可随时删除索引
- ⚠️ **索引空间**：预计增加 1-5MB（取决于数据量）
- ⚠️ **写入性能**：INSERT/UPDATE 略微变慢（通常 <5%）

### 建议
1. ✅ **立即执行**：添加组合索引
2. 🔍 **监控观察**：观察是否有重复寄售问题
3. 💡 **按需优化**：如果发现并发问题，再添加应用层锁
